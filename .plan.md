# Battle Matchmaking Features Plan

## Overview
Add two ways to battle real people:
1. **Random Active User** - Match with someone currently online
2. **SMS Invitation** - Text a friend to invite them to battle

---

## Feature 1: Random Active User Matching

### Goal
When a user clicks "Find Random Opponent", match them with someone who's currently active on the platform (not just in the matchmaking queue).

### Implementation

#### 1.1 Add Activity Tracking to User Model
```python
# core/users/models.py - Add to User model
last_seen_at = models.DateTimeField(
    null=True, blank=True, db_index=True,
    help_text='Last time user was active (API request)'
)
is_available_for_battles = models.BooleanField(
    default=True,
    help_text='User is open to receiving random battle invitations'
)
```

#### 1.2 Create Activity Tracking Middleware
```python
# core/users/middleware.py
class UserActivityMiddleware:
    """Update user's last_seen_at on authenticated requests."""

    THROTTLE_SECONDS = 60  # Only update once per minute to reduce DB writes

    def __call__(self, request):
        if request.user.is_authenticated:
            # Use Redis to throttle updates
            cache_key = f'user_activity:{request.user.id}'
            if not cache.get(cache_key):
                User.objects.filter(id=request.user.id).update(
                    last_seen_at=timezone.now()
                )
                cache.set(cache_key, True, self.THROTTLE_SECONDS)
        return self.get_response(request)
```

#### 1.3 Add New Match Type
```python
# core/battles/models.py - Add to MatchSource
ACTIVE_USER = 'active_user', 'Active User Match'
```

#### 1.4 Enhance MatchmakingConsumer
```python
# core/battles/consumers.py - Add to MatchmakingConsumer
async def _handle_join_queue(self, match_type, challenge_type_key):
    if match_type == 'active_user':
        match = await self._find_active_user_match(challenge_type_key)
        if match:
            # Match found! Create battle and notify
            ...
        else:
            # No active users - offer to play vs AI or wait in queue
            await self._send_no_active_users()
```

```python
@database_sync_to_async
def _find_active_user_match(self, challenge_type_key):
    """Find a random active user to battle."""
    from datetime import timedelta

    # Active = seen in last 5 minutes
    active_threshold = timezone.now() - timedelta(minutes=5)

    active_users = User.objects.filter(
        last_seen_at__gte=active_threshold,
        is_available_for_battles=True,
        role__in=[UserRole.EXPLORER, UserRole.LEARNER, UserRole.EXPERT, UserRole.CREATOR],
    ).exclude(
        id=self.user.id  # Not yourself
    ).exclude(
        # Not users already in active battles
        Q(battles_initiated__status=BattleStatus.ACTIVE) |
        Q(battles_received__status=BattleStatus.ACTIVE)
    ).order_by('?')[:10]  # Random sample

    if not active_users:
        return None

    # Pick one randomly
    opponent = random.choice(list(active_users))

    # Create battle invitation (not instant match - let them accept)
    # This is more polite than forcing them into a battle
    ...
```

#### 1.5 Frontend Flow
```
User clicks "Find Random Opponent"
    â†“
WebSocket: { type: 'join_queue', match_type: 'active_user' }
    â†“
Backend finds active user, sends invitation
    â†“
User sees "Invitation sent to @username - waiting for response..."
    â†“
Opponent gets real-time notification
    â†“
If accepted: both redirect to battle
If declined/timeout: offer to try again or play vs AI
```

### Files to Modify
- `core/users/models.py` - Add `last_seen_at`, `is_available_for_battles`
- `core/users/middleware.py` - Create activity tracking middleware
- `config/settings.py` - Add middleware to MIDDLEWARE
- `core/battles/models.py` - Add `ACTIVE_USER` match source
- `core/battles/consumers.py` - Add `_find_active_user_match`
- `frontend/src/hooks/useMatchmaking.ts` - Add active user match type
- `frontend/src/pages/battles/BattleLobbyPage.tsx` - Add UI for finding active users

### Migration
```bash
python manage.py makemigrations users --name add_activity_tracking
python manage.py migrate
```

---

## Feature 2: SMS Battle Invitations

### Goal
Let users invite friends to battle via SMS, even if the friend doesn't have an account yet.

### Implementation

#### 2.1 Add Phone Fields to User Model
```python
# core/users/models.py - Add to User model
phone_number = models.CharField(
    max_length=20, blank=True, db_index=True,
    validators=[phone_regex],
    help_text='Phone number in E.164 format (e.g., +14155551234)'
)
phone_verified = models.BooleanField(default=False)
phone_verified_at = models.DateTimeField(null=True, blank=True)
allow_sms_invitations = models.BooleanField(
    default=True,
    help_text='Allow receiving battle invitations via SMS'
)
```

#### 2.2 Create SMS Service
```python
# core/sms/__init__.py
# core/sms/apps.py
# core/sms/provider.py

from abc import ABC, abstractmethod
from twilio.rest import Client

class SMSProvider(ABC):
    @abstractmethod
    def send(self, to: str, body: str) -> dict:
        pass

class TwilioProvider(SMSProvider):
    def __init__(self):
        self.client = Client(
            settings.TWILIO_ACCOUNT_SID,
            settings.TWILIO_AUTH_TOKEN
        )
        self.from_number = settings.TWILIO_PHONE_NUMBER

    def send(self, to: str, body: str) -> dict:
        message = self.client.messages.create(
            body=body,
            from_=self.from_number,
            to=to
        )
        return {
            'sid': message.sid,
            'status': message.status,
        }

# For development/testing without Twilio
class ConsoleSMSProvider(SMSProvider):
    def send(self, to: str, body: str) -> dict:
        logger.info(f"[SMS] To: {to}\n{body}")
        return {'sid': 'console', 'status': 'logged'}
```

#### 2.3 Create SMS Log Model
```python
# core/sms/models.py
class SMSLog(models.Model):
    """Track sent SMS messages for audit and debugging."""

    class Status(models.TextChoices):
        PENDING = 'pending', 'Pending'
        SENT = 'sent', 'Sent'
        DELIVERED = 'delivered', 'Delivered'
        FAILED = 'failed', 'Failed'

    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True)
    to_phone = models.CharField(max_length=20)
    body = models.TextField()
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.PENDING)
    provider_sid = models.CharField(max_length=100, blank=True)
    error_message = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']
```

#### 2.4 Extend BattleInvitation
```python
# core/battles/models.py - Add to BattleInvitation
notification_method = models.CharField(
    max_length=20,
    choices=[('in_app', 'In-App'), ('sms', 'SMS'), ('email', 'Email')],
    default='in_app'
)
recipient_phone = models.CharField(max_length=20, blank=True)
sms_sent = models.BooleanField(default=False)
sms_sent_at = models.DateTimeField(null=True, blank=True)
# For non-users - store invite token
invite_token = models.CharField(max_length=64, blank=True, db_index=True)
```

#### 2.5 Create SMS Invitation Endpoint
```python
# core/battles/views.py - Add to BattleInvitationViewSet
@action(detail=False, methods=['post'])
def invite_via_sms(self, request):
    """Send battle invitation via SMS."""
    phone = request.data.get('phone_number')
    message = request.data.get('message', '')
    challenge_type_key = request.data.get('challenge_type')

    # Validate phone number format
    phone = normalize_phone(phone)
    if not is_valid_phone(phone):
        return Response({'error': 'Invalid phone number'}, status=400)

    # Check if phone belongs to existing user
    existing_user = User.objects.filter(phone_number=phone, phone_verified=True).first()

    if existing_user:
        # Create normal invitation
        invitation = create_invitation(
            sender=request.user,
            recipient=existing_user,
            notification_method='sms',
        )
        # Send in-app notification + SMS
        send_battle_sms.delay(invitation.id)
    else:
        # Create invitation for non-user
        invitation = create_invitation_for_phone(
            sender=request.user,
            phone=phone,
            message=message,
        )
        # Send SMS with signup link
        send_battle_sms_new_user.delay(invitation.id)

    return Response({
        'invitation_id': invitation.id,
        'status': 'sent'
    })
```

#### 2.6 SMS Templates
```python
# Existing user
f"""
ðŸŽ® {sender.username} challenged you to a Prompt Battle!

Challenge: {challenge_text[:100]}

Accept: {frontend_url}/battles/invite/{invite_token}

Reply STOP to opt out.
"""

# New user
f"""
ðŸŽ® {sender.username} challenged you to a Prompt Battle on AllThrive!

Sign up to compete: {frontend_url}/signup?invite={invite_token}

AllThrive is where creators battle with AI art prompts.
"""
```

#### 2.7 Celery Tasks
```python
# core/sms/tasks.py
@shared_task
def send_battle_sms(invitation_id: int):
    """Send SMS for battle invitation."""
    invitation = BattleInvitation.objects.get(id=invitation_id)
    provider = get_sms_provider()

    body = render_battle_invite_sms(invitation)
    result = provider.send(invitation.recipient_phone, body)

    # Log
    SMSLog.objects.create(
        user=invitation.recipient,
        to_phone=invitation.recipient_phone,
        body=body,
        status='sent' if result.get('sid') else 'failed',
        provider_sid=result.get('sid', ''),
    )

    invitation.sms_sent = True
    invitation.sms_sent_at = timezone.now()
    invitation.save()
```

#### 2.8 Settings
```python
# config/settings.py
TWILIO_ACCOUNT_SID = config('TWILIO_ACCOUNT_SID', default='')
TWILIO_AUTH_TOKEN = config('TWILIO_AUTH_TOKEN', default='')
TWILIO_PHONE_NUMBER = config('TWILIO_PHONE_NUMBER', default='')

# Use console provider if Twilio not configured
SMS_PROVIDER = 'twilio' if TWILIO_ACCOUNT_SID else 'console'
```

### Files to Create
- `core/sms/__init__.py`
- `core/sms/apps.py`
- `core/sms/admin.py`
- `core/sms/models.py`
- `core/sms/provider.py`
- `core/sms/tasks.py`
- `core/sms/utils.py` (phone validation)

### Files to Modify
- `core/users/models.py` - Add phone fields
- `core/battles/models.py` - Extend BattleInvitation
- `core/battles/views.py` - Add SMS invitation endpoint
- `core/battles/serializers.py` - Add SMS invitation serializer
- `config/settings.py` - Add Twilio settings, SMS app
- `requirements.txt` - Add `twilio`

### Frontend Changes
- `frontend/src/pages/battles/BattleLobbyPage.tsx` - Add "Invite Friend" button
- `frontend/src/components/battles/InviteFriendModal.tsx` - Phone input form
- `frontend/src/pages/battles/AcceptInvitePage.tsx` - Handle invite token

---

## Implementation Order

### Phase 1: Foundation (Both features share)
1. Add `last_seen_at` to User model
2. Create activity tracking middleware
3. Add phone fields to User model
4. Create migrations

### Phase 2: Random Active User
1. Add `is_available_for_battles` setting
2. Implement `_find_active_user_match` in consumer
3. Add frontend UI for finding active users
4. Add real-time notifications for match requests

### Phase 3: SMS Infrastructure
1. Create `core/sms` app
2. Implement TwilioProvider and ConsoleSMSProvider
3. Create SMSLog model
4. Add Celery tasks

### Phase 4: SMS Invitations
1. Extend BattleInvitation model
2. Create SMS invitation endpoint
3. Create SMS templates
4. Build frontend invite modal
5. Handle invite token acceptance

### Phase 5: Polish
1. Phone verification flow
2. SMS opt-out handling
3. Rate limiting for SMS sends
4. Analytics/tracking

---

## Database Migrations Summary

```sql
-- User model additions
ALTER TABLE users_user ADD COLUMN last_seen_at TIMESTAMP NULL;
ALTER TABLE users_user ADD COLUMN is_available_for_battles BOOLEAN DEFAULT TRUE;
ALTER TABLE users_user ADD COLUMN phone_number VARCHAR(20) DEFAULT '';
ALTER TABLE users_user ADD COLUMN phone_verified BOOLEAN DEFAULT FALSE;
ALTER TABLE users_user ADD COLUMN phone_verified_at TIMESTAMP NULL;
ALTER TABLE users_user ADD COLUMN allow_sms_invitations BOOLEAN DEFAULT TRUE;

-- BattleInvitation additions
ALTER TABLE battles_battleinvitation ADD COLUMN notification_method VARCHAR(20) DEFAULT 'in_app';
ALTER TABLE battles_battleinvitation ADD COLUMN recipient_phone VARCHAR(20) DEFAULT '';
ALTER TABLE battles_battleinvitation ADD COLUMN sms_sent BOOLEAN DEFAULT FALSE;
ALTER TABLE battles_battleinvitation ADD COLUMN sms_sent_at TIMESTAMP NULL;
ALTER TABLE battles_battleinvitation ADD COLUMN invite_token VARCHAR(64) DEFAULT '';

-- New SMSLog table
CREATE TABLE sms_smslog (...);
```

---

## External Dependencies

### Twilio Setup Required
1. Create Twilio account at https://www.twilio.com
2. Get Account SID and Auth Token
3. Purchase a phone number with SMS capability
4. Add to `.env`:
   ```
   TWILIO_ACCOUNT_SID=ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
   TWILIO_AUTH_TOKEN=your_auth_token
   TWILIO_PHONE_NUMBER=+14155551234
   ```

### Cost Estimate
- Twilio SMS: ~$0.0079 per message (US)
- Consider rate limiting to prevent abuse
- Track costs in SMSLog for monitoring

---

## Security Considerations

1. **Phone number validation** - Use `phonenumbers` library for E.164 validation
2. **Rate limiting** - Max 5 SMS invites per user per hour
3. **Opt-out** - Honor STOP replies, track in user preferences
4. **Invite token security** - Use cryptographically random tokens, expire after 7 days
5. **TCPA compliance** - Only send to users who haven't opted out
