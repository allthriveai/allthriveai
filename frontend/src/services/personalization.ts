import { api } from './api';
import type {
  Taxonomy,
  UserTag,
  UserPersonalization,
  InteractionType
} from '@/types/models';

/**
 * Paginated API response type
 */
interface PaginatedResponse<T> {
  results?: T[];
  next?: string | null;
}

/**
 * Get all available taxonomies
 * Fetches all pages if paginated
 */
export async function getTaxonomies(): Promise<Taxonomy[]> {
  let allTaxonomies: Taxonomy[] = [];
  let nextUrl: string | null = '/taxonomies/';

  // Fetch all pages
  while (nextUrl) {
    const response: { data: PaginatedResponse<Taxonomy> | Taxonomy[] } = await api.get<PaginatedResponse<Taxonomy> | Taxonomy[]>(nextUrl);
    const data: PaginatedResponse<Taxonomy> | Taxonomy[] = response.data;

    // Handle both paginated and non-paginated responses
    if (Array.isArray(data)) {
      // Non-paginated response
      allTaxonomies = data;
      nextUrl = null;
    } else if (data.results) {
      // Paginated response
      allTaxonomies = allTaxonomies.concat(data.results);
      // Extract relative path from next URL
      const nextUrlValue: string | null | undefined = data.next;
      if (nextUrlValue) {
        try {
          const parsedUrl: URL = new URL(nextUrlValue);
          nextUrl = (parsedUrl.pathname + parsedUrl.search).replace('/api/v1', '');
        } catch {
          // Invalid URL, stop pagination
          nextUrl = null;
        }
      } else {
        nextUrl = null;
      }
    } else {
      // Unexpected format, stop pagination
      nextUrl = null;
    }
  }

  return allTaxonomies;
}

/**
 * Get taxonomies grouped by category
 */
export async function getTaxonomiesByCategory(): Promise<Record<string, Taxonomy[]>> {
  const response = await api.get('/taxonomies/by_category/');
  return response.data;
}

/**
 * Get user's personalization overview
 */
export async function getUserPersonalization(): Promise<UserPersonalization> {
  const response = await api.get('/me/personalization/');
  return response.data;
}

/**
 * Get user's manual tags
 */
export async function getManualTags(): Promise<UserTag[]> {
  const response = await api.get('/me/tags/manual/');
  return response.data;
}

/**
 * Get user's auto-generated tags
 */
export async function getAutoGeneratedTags(): Promise<UserTag[]> {
  const response = await api.get('/me/tags/auto_generated/');
  return response.data;
}

/**
 * Get all user tags
 */
export async function getAllUserTags(): Promise<UserTag[]> {
  const response = await api.get('/me/tags/');
  return response.data;
}

/**
 * Create a single manual tag
 */
export async function createUserTag(data: {
  taxonomy?: number;
  name?: string;
}): Promise<UserTag> {
  const response = await api.post('/me/tags/', data);
  return response.data;
}

/**
 * Create multiple tags from taxonomy selections
 */
export async function bulkCreateTags(taxonomyIds: number[]): Promise<UserTag[]> {
  const response = await api.post('/me/tags/bulk_create/', {
    taxonomy_ids: taxonomyIds,
  });
  return response.data;
}

/**
 * Delete a single tag
 */
export async function deleteUserTag(tagId: number): Promise<void> {
  await api.delete(`/me/tags/${tagId}/`);
}

/**
 * Delete multiple tags
 */
export async function bulkDeleteTags(tagIds: number[]): Promise<{ deleted: number }> {
  const response = await api.delete('/me/tags/bulk_delete/', {
    data: { tag_ids: tagIds },
  });
  return response.data;
}

/**
 * Track a user interaction
 */
export async function trackInteraction(data: {
  interactionType: InteractionType;
  metadata?: Record<string, any>;
  extractedKeywords?: string[];
}): Promise<void> {
  await api.post('/me/interactions/', {
    interaction_type: data.interactionType,
    metadata: data.metadata || {},
    extracted_keywords: data.extractedKeywords || [],
  });
}

/**
 * Personalization settings type
 * Note: Uses camelCase to match the API response after axios interceptor transforms snake_case to camelCase
 */
export interface PersonalizationSettings {
  useTopicSelections: boolean;
  learnFromViews: boolean;
  learnFromLikes: boolean;
  considerSkillLevel: boolean;
  factorContentDifficulty: boolean;
  useSocialSignals: boolean;
  discoveryBalance: number;
  allowTimeTracking: boolean;
  allowScrollTracking: boolean;
  excitedFeatures: string[];
  desiredIntegrations: string[];
  desiredIntegrationsOther: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * Get user's personalization settings
 */
export async function getPersonalizationSettings(): Promise<PersonalizationSettings> {
  const response = await api.get('/me/personalization/settings/');
  return response.data;
}

/**
 * Update user's personalization settings
 */
export async function updatePersonalizationSettings(
  settings: Partial<PersonalizationSettings>
): Promise<PersonalizationSettings> {
  const response = await api.patch('/me/personalization/settings/', settings);
  return response.data;
}

/**
 * Reset personalization settings to defaults
 */
export async function resetPersonalizationSettings(): Promise<{
  message: string;
  settings: PersonalizationSettings;
}> {
  const response = await api.post('/me/personalization/settings/reset/');
  return response.data;
}

/**
 * Export personalization data response type
 */
export interface PersonalizationExport {
  exportedAt: string;
  user: {
    id: number;
    username: string;
  };
  personalizationSettings: PersonalizationSettings | null;
  manualTags: Array<{
    id: number;
    name: string;
    taxonomy: {
      id: number;
      name: string;
      category: string;
    } | null;
    createdAt: string;
  }>;
  autoGeneratedTags: Array<{
    id: number;
    name: string;
    confidenceScore: number;
    interactionCount: number;
    taxonomy: {
      id: number;
      name: string;
      category: string;
    } | null;
    createdAt: string;
    updatedAt: string;
  }>;
  interactionSummaryLast90Days: Record<string, number>;
}

/**
 * Export all personalization data (GDPR data portability)
 */
export async function exportPersonalizationData(): Promise<PersonalizationExport> {
  const response = await api.get('/me/personalization/export/');
  return response.data;
}

/**
 * Delete personalization data response type
 */
export interface PersonalizationDeleteResult {
  message: string;
  deleted: {
    tags: number;
    interactions: number;
    settings: number;
  };
}

/**
 * Delete all personalization data (GDPR right to erasure)
 */
export async function deletePersonalizationData(): Promise<PersonalizationDeleteResult> {
  const response = await api.delete('/me/personalization/delete/');
  return response.data;
}
