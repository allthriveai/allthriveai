# Project Portfolio Template System

## Problem Statement

Currently, project pages are generated by parsing README markdown into free-form blocks. This results in:
- **Inconsistent layouts** - Every project looks different
- **AI slop appearance** - Walls of text without visual structure
- **No clear information hierarchy** - Important details get lost
- **Hard to edit** - Users have to understand the block system

## Vision: Section-Based Templates

Instead of free-form blocks, use a **structured section template** where:
1. Each section has a defined purpose and visual treatment
2. AI fills section-specific content (not free-form markdown)
3. Empty sections are gracefully hidden
4. Users can enable/disable and reorder sections
5. Consistent, beautiful rendering across all projects

---

## Proposed Section Types

### 1. Hero Section (Already Exists)
**Purpose:** First impression - project identity and hook
- Title + tagline
- Author badge
- Hero visual (image/video/slideshow/quote)
- CTA buttons (GitHub, Demo, etc.)
- Tools used badges

### 2. Overview Section (NEW)
**Purpose:** Quick "what is this?" - scannable summary
```typescript
interface OverviewSection {
  headline: string;      // One-liner hook (bold, large text)
  description: string;   // 2-3 sentences max (markdown)
  metrics?: Metric[];    // Optional: Stars, downloads, etc.
}
interface Metric {
  icon: string;   // "star" | "download" | "user" | "code"
  label: string;  // "GitHub Stars"
  value: string;  // "1.2k"
}
```
**Visual:** Clean card with optional metric pills

### 3. Features Section (NEW)
**Purpose:** What makes this project special - visual highlight grid
```typescript
interface FeaturesSection {
  features: Feature[];
}
interface Feature {
  icon: string;         // emoji or icon name
  title: string;        // "Blazing Fast"
  description: string;  // 1-2 sentences
}
```
**Visual:** 2-3 column grid of icon cards

### 4. Tech Stack Section (NEW)
**Purpose:** Technologies used - credibility and searchability
```typescript
interface TechStackSection {
  categories: TechCategory[];
}
interface TechCategory {
  name: string;           // "Frontend" | "Backend" | "Infrastructure"
  technologies: Tech[];
}
interface Tech {
  name: string;    // "React"
  icon?: string;   // URL or icon name (SimpleIcons)
  version?: string;
}
```
**Visual:** Horizontal badges grouped by category, with logos

### 5. Gallery Section (NEW)
**Purpose:** Visual proof - screenshots and demos
```typescript
interface GallerySection {
  images: GalleryImage[];
  layout: 'carousel' | 'grid' | 'masonry';
}
interface GalleryImage {
  url: string;
  caption?: string;
  thumbnail?: string;
}
```
**Visual:** Interactive carousel or responsive grid

### 6. Architecture Section (Enhanced)
**Purpose:** Technical depth - how it works
```typescript
interface ArchitectureSection {
  diagram: string;         // Mermaid code
  description?: string;    // Brief explanation
  title?: string;          // "System Architecture"
}
```
**Visual:** Centered diagram with caption, dark/light mode support

### 7. Demo Section (NEW)
**Purpose:** Try it out - reduce friction to engagement
```typescript
interface DemoSection {
  video?: VideoEmbed;      // YouTube, Vimeo, Loom, or uploaded
  liveUrl?: string;        // Link to live demo
  ctas: DemoCTA[];
}
interface DemoCTA {
  label: string;   // "Try Demo"
  url: string;
  style: 'primary' | 'secondary';
}
```
**Visual:** Embedded video or prominent CTA buttons

### 8. Challenges & Learnings Section (NEW)
**Purpose:** Storytelling - demonstrates growth and problem-solving
```typescript
interface ChallengesSection {
  items: Challenge[];
}
interface Challenge {
  challenge: string;   // "Handling 10k concurrent users"
  solution: string;    // "Implemented Redis caching..."
  outcome?: string;    // "Reduced response time by 80%"
}
```
**Visual:** Before/after cards or accordion

### 9. Links Section (NEW)
**Purpose:** Resources and references
```typescript
interface LinksSection {
  links: ResourceLink[];
}
interface ResourceLink {
  label: string;       // "Documentation"
  url: string;
  icon?: string;       // "book" | "video" | "github"
  description?: string;
}
```
**Visual:** Compact link list with icons

### 10. Custom Section (Flexibility)
**Purpose:** Free-form blocks for anything else
```typescript
interface CustomSection {
  title?: string;
  blocks: ProjectBlock[];  // Existing block types
}
```
**Visual:** Current block rendering

---

## Data Structure

### New Project Content Schema
```typescript
interface ProjectContent {
  // Template version for migrations
  templateVersion: 2;

  // Section configuration
  sections: ProjectSection[];

  // Legacy support
  blocks?: ProjectBlock[];  // For backwards compatibility

  // Hero settings (already exist)
  heroDisplayMode: 'image' | 'video' | 'slideshow' | 'quote' | 'slideup';
  heroQuote?: string;
  heroVideoUrl?: string;
  heroSlideshowImages?: string[];

  // Raw data (for regeneration)
  github?: GitHubRepoData;
}

interface ProjectSection {
  id: string;
  type: SectionType;
  enabled: boolean;
  order: number;
  content: SectionContent;  // Type-specific content
}

type SectionType =
  | 'overview'
  | 'features'
  | 'tech_stack'
  | 'gallery'
  | 'architecture'
  | 'demo'
  | 'challenges'
  | 'links'
  | 'custom';
```

---

## AI Generation Changes

### Current Flow (Problems)
1. Parse README into markdown blocks
2. AI "transforms" blocks into "compelling copy"
3. AI suggests layout groupings
4. Result: Still looks like README ‚Üí inconsistent

### New Flow (Proposed)
1. Analyze repo (README, file tree, deps, tech stack)
2. AI generates **section-specific structured data**
3. Each section type has its own AI prompt and output schema
4. Result: Consistent, visually appealing sections

### New AI Prompt Structure
```python
def analyze_for_template(repo_data: dict, readme: str) -> dict:
    """Generate section-specific content for template."""

    return {
        "overview": {
            "headline": "AI-generated one-liner...",
            "description": "2-3 sentence summary...",
            "metrics": [...]
        },
        "features": [
            {"icon": "‚ö°", "title": "...", "description": "..."},
            ...
        ],
        "tech_stack": {
            "categories": [
                {"name": "Backend", "technologies": [...]},
                ...
            ]
        },
        "architecture": {
            "diagram": "graph TB...",
            "description": "..."
        },
        "challenges": [...],
        # Only populated if README has relevant content
        "demo": {...} if has_demo else None,
        "gallery": [...] if has_screenshots else None,
    }
```

---

## Frontend Implementation

### Section Renderers
Create dedicated components for each section type:

```
frontend/src/components/projects/sections/
‚îú‚îÄ‚îÄ OverviewSection.tsx
‚îú‚îÄ‚îÄ FeaturesSection.tsx
‚îú‚îÄ‚îÄ TechStackSection.tsx
‚îú‚îÄ‚îÄ GallerySection.tsx
‚îú‚îÄ‚îÄ ArchitectureSection.tsx
‚îú‚îÄ‚îÄ DemoSection.tsx
‚îú‚îÄ‚îÄ ChallengesSection.tsx
‚îú‚îÄ‚îÄ LinksSection.tsx
‚îú‚îÄ‚îÄ CustomSection.tsx
‚îî‚îÄ‚îÄ SectionRenderer.tsx  # Routes to correct component
```

### Section Rendering
```tsx
function ProjectSections({ sections }: { sections: ProjectSection[] }) {
  return (
    <div className="space-y-16">
      {sections
        .filter(s => s.enabled)
        .sort((a, b) => a.order - b.order)
        .map(section => (
          <SectionRenderer key={section.id} section={section} />
        ))}
    </div>
  );
}
```

### Editing Experience
- Toggle sections on/off
- Drag to reorder
- Edit section content in forms (not raw blocks)
- "Add custom section" for free-form

---

## Migration Strategy

### Phase 1: New Schema + Renderers
1. Define TypeScript interfaces for all section types
2. Create section renderer components
3. Update `ProjectDetailPage` to use new renderers
4. Keep backwards compatibility with `blocks` array

### Phase 2: AI Generation
1. Create new `analyze_for_template()` function
2. Add template-specific prompts for each section
3. Update `import_github_project` to use new generator
4. Map AI output to section content

### Phase 3: Editor Updates
1. Add section toggle/reorder UI
2. Create section-specific edit forms
3. Update `ProjectEditor` to handle sections
4. Allow adding custom sections

### Phase 4: Migration + Cleanup
1. Add migration command for existing projects
2. Regenerate sections for GitHub projects
3. Deprecate raw `blocks` for new projects
4. Update documentation

---

## Visual Design Guidelines

### Consistent Section Styling
```css
/* Each section has consistent spacing and borders */
.project-section {
  padding: 3rem 0;
  border-bottom: 1px solid var(--border-color);
}

.project-section:last-child {
  border-bottom: none;
}

.section-header {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.section-title {
  font-size: 1.5rem;
  font-weight: 700;
}

.section-divider {
  flex: 1;
  height: 1px;
  background: var(--border-color);
}
```

### Feature Cards
- Subtle shadow on hover
- Icon with brand color background
- Title bold, description muted
- Even spacing, consistent heights

### Tech Stack Badges
- Horizontal scrolling on mobile
- Category labels as subtle headings
- Technology logos from SimpleIcons
- Hover to show version/details

### Gallery
- Lightbox on click
- Keyboard navigation
- Touch gestures on mobile
- Lazy loading

---

## Success Metrics

1. **Visual Consistency**: All projects have same section structure
2. **Engagement**: Time on page, scroll depth
3. **Editing**: Users can easily toggle/edit sections
4. **Load Time**: No regression from new renderers
5. **AI Quality**: Sections are accurately populated

---

## Example: Redis Wellness Project

### Current (Free-form blocks)
```
[badgeRow] Python | TypeScript | Redis | FastAPI
[text] Comparing stateless and stateful...
[text] **Unlock the power of agentic AI**...
[columns] Feature list...
[text] More text...
[mermaid] graph TB...
```

### New (Structured sections)
```yaml
sections:
  - type: overview
    headline: "AI-powered wellness insights from your health data"
    description: "Compare stateless vs stateful RAG approaches..."
    metrics:
      - {icon: "star", label: "Stars", value: "42"}
      - {icon: "code", label: "Language", value: "Python"}

  - type: features
    features:
      - {icon: "üîí", title: "100% Private", description: "Runs locally..."}
      - {icon: "üß†", title: "Agentic RAG", description: "Compare approaches..."}
      - {icon: "‚ù§Ô∏è", title: "Apple Health", description: "Import your data..."}

  - type: tech_stack
    categories:
      - name: "Backend"
        technologies: ["Python", "FastAPI", "Redis", "LangChain"]
      - name: "AI"
        technologies: ["Ollama", "RedisVL"]
      - name: "Infrastructure"
        technologies: ["Docker", "Docker Compose"]

  - type: architecture
    diagram: "graph TB..."
    description: "Data flows from Apple Health..."

  - type: gallery
    images:
      - {url: "screenshot1.png", caption: "Dashboard view"}
      - {url: "screenshot2.png", caption: "RAG comparison"}
```

---

## Open Questions

1. **Default Section Order**: What's the optimal default order?
2. **Required Sections**: Should any sections be mandatory?
3. **Custom Section Limit**: How many custom sections allowed?
4. **Template Presets**: Different templates for GitHub vs other types?
5. **Regeneration**: Can users regenerate AI content for individual sections?

---

## Next Steps

1. [ ] Review and approve this plan
2. [ ] Define TypeScript interfaces for all section types
3. [ ] Create mock designs for each section renderer
4. [ ] Implement section renderers (read-only first)
5. [ ] Update AI analyzer for template generation
6. [ ] Add section editing UI
7. [ ] Test with real projects
8. [ ] Migrate existing projects
