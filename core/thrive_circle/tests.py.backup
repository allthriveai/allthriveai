"""
Tests for Thrive Circle gamification system.
"""

import datetime
from datetime import date, timedelta
from unittest.mock import patch

from django.contrib.auth import get_user_model
from django.db import IntegrityError, transaction
from django.test import TestCase
from django.utils import timezone
from django.utils.crypto import get_random_string
from rest_framework import status
from rest_framework.test import APITestCase

from .models import SideQuest, UserSideQuest, WeeklyGoal, PointActivity
from .services import PointsService
from .tasks import check_streak_bonuses, create_weekly_goals
from .utils import get_week_start

User = get_user_model()


class UserPointsModelTest(TestCase):
    """Tests for User model points system"""

    def setUp(self):
        self.user = User.objects.create_user(username='testuser', email='test@example.com', password='testpass123')  # noqa: S106

    def test_user_default_tier(self):
        """Test user starts with default tier"""
        self.assertEqual(self.user.tier, 'ember')
        self.assertEqual(self.user.total_points, 0)

    def test_tier_progression_ember_to_spark(self):
        """Test tier upgrade from Ember to Spark at 250 points"""
        self.user.add_points(250, 'quiz_complete', 'Test quiz')
        self.user.refresh_from_db()
        self.assertEqual(self.user.tier, 'spark')
        self.assertEqual(self.user.total_points, 250)

    def test_tier_progression_ember_to_blaze(self):
        """Test tier upgrade from Ember to Blaze at 500 points"""
        self.user.add_points(500, 'special_event', 'Bonus points')
        self.user.refresh_from_db()
        self.assertEqual(self.user.tier, 'blaze')
        self.assertEqual(self.user.total_points, 500)

    def test_tier_progression_to_phoenix(self):
        """Test tier upgrade to Phoenix at 2500 points"""
        self.user.add_points(2500, 'special_event', 'Massive points')
        self.user.refresh_from_db()
        self.assertEqual(self.user.tier, 'phoenix')
        self.assertEqual(self.user.total_points, 2500)

    def test_incremental_tier_progression(self):
        """Test tier upgrades happen incrementally"""
        # Ember -> Spark
        self.user.add_points(200, 'quiz_complete')
        self.user.refresh_from_db()
        self.assertEqual(self.user.tier, 'ember')

        self.user.add_points(50, 'quiz_complete')
        self.user.refresh_from_db()
        self.assertEqual(self.user.tier, 'spark')
        self.assertEqual(self.user.total_points, 250)

        # Spark -> Blaze
        self.user.add_points(250, 'project_create')
        self.user.refresh_from_db()
        self.assertEqual(self.user.tier, 'blaze')
        self.assertEqual(self.user.total_points, 500)

    def test_add_points_creates_activity(self):
        """Test that adding points creates an activity record"""
        self.user.add_points(100, 'quiz_complete', 'Test quiz completed')

        activity = PointActivity.objects.filter(user=self.user).first()
        self.assertIsNotNone(activity)
        self.assertEqual(activity.amount, 100)
        self.assertEqual(activity.activity_type, 'quiz_complete')
        self.assertEqual(activity.description, 'Test quiz completed')

    def test_add_points_rejects_negative(self):
        """Test that negative points are rejected"""
        with self.assertRaises(ValueError):
            self.user.add_points(-50, 'quiz_complete')

    def test_add_points_rejects_zero(self):
        """Test that zero points are rejected"""
        with self.assertRaises(ValueError):
            self.user.add_points(0, 'quiz_complete')

    def test_concurrent_points_additions(self):
        """Test that concurrent points additions don't create race conditions"""
        # Add points in sequence
        self.user.add_points(100, 'quiz_complete')
        self.user.add_points(200, 'project_create')

        # Total should be 300
        self.user.refresh_from_db()
        self.assertEqual(self.user.total_points, 300)


class PointsServiceTest(TestCase):
    """Tests for Points service layer"""

    def test_calculate_quiz_points_perfect_score(self):
        """Test points calculation for perfect quiz score"""
        points = PointsService.calculate_quiz_points(100)
        # Base (10) + Bonus (100 * 0.4 = 40) + Perfect bonus (10) = 60
        self.assertEqual(points, 60)

    def test_calculate_quiz_points_zero_score(self):
        """Test points calculation for zero quiz score"""
        points = PointsService.calculate_quiz_points(0)
        # Base (10) + Bonus (0 * 0.4 = 0) = 10
        self.assertEqual(points, 10)

    def test_calculate_quiz_points_mid_score(self):
        """Test points calculation for mid-range quiz score"""
        points = PointsService.calculate_quiz_points(75)
        # Base (10) + Bonus (75 * 0.4 = 30) = 40
        self.assertEqual(points, 40)

    def test_calculate_quiz_points_invalid_score(self):
        """Test that invalid scores are rejected"""
        with self.assertRaises(ValueError):
            PointsService.calculate_quiz_points(-10)

        with self.assertRaises(ValueError):
            PointsService.calculate_quiz_points(150)

    def test_get_tier_for_points(self):
        """Test tier determination from points"""
        self.assertEqual(PointsService.get_tier_for_points(0), 'ember')
        self.assertEqual(PointsService.get_tier_for_points(249), 'ember')
        self.assertEqual(PointsService.get_tier_for_points(250), 'spark')
        self.assertEqual(PointsService.get_tier_for_points(499), 'spark')
        self.assertEqual(PointsService.get_tier_for_points(500), 'blaze')
        self.assertEqual(PointsService.get_tier_for_points(999), 'blaze')
        self.assertEqual(PointsService.get_tier_for_points(1000), 'beacon')
        self.assertEqual(PointsService.get_tier_for_points(2499), 'beacon')
        self.assertEqual(PointsService.get_tier_for_points(2500), 'phoenix')
        self.assertEqual(PointsService.get_tier_for_points(99999), 'phoenix')

    def test_get_points_to_next_tier(self):
        """Test points needed to reach next tier"""
        next_tier, points_needed = PointsService.get_points_to_next_tier(100)
        self.assertEqual(next_tier, 'spark')
        self.assertEqual(points_needed, 150)  # 250 - 100

        next_tier, points_needed = PointsService.get_points_to_next_tier(300)
        self.assertEqual(next_tier, 'blaze')
        self.assertEqual(points_needed, 200)  # 500 - 300

        next_tier, points_needed = PointsService.get_points_to_next_tier(3000)
        self.assertEqual(next_tier, 'phoenix')
        self.assertEqual(points_needed, 0)  # Already at max

    def test_validate_points_award_positive(self):
        """Test points validation accepts valid awards"""
        # Should not raise
        PointsService.validate_points_award(50, 'quiz_complete')
        PointsService.validate_points_award(1, 'comment')
        PointsService.validate_points_award(1000, 'special_event')

    def test_validate_points_award_negative(self):
        """Test points validation rejects negative awards"""
        with self.assertRaises(ValueError):
            PointsService.validate_points_award(-50, 'quiz_complete')

    def test_validate_points_award_zero(self):
        """Test points validation rejects zero awards"""
        with self.assertRaises(ValueError):
            PointsService.validate_points_award(0, 'quiz_complete')

    def test_validate_points_award_excessive(self):
        """Test points validation rejects excessive awards"""
        with self.assertRaises(ValueError):
            PointsService.validate_points_award(10000, 'quiz_complete')


class ThriveCircleAPITest(APITestCase):
    """Tests for Thrive Circle API endpoints"""

    def setUp(self):
        self.user = User.objects.create_user(username='testuser', email='test@example.com', password='testpass123')  # noqa: S106
        self.client.force_authenticate(user=self.user)

    def test_my_status_endpoint(self):
        """Test GET /api/v1/me/thrive-circle/my_status/"""
        # Set to spark tier manually for testing
        self.user.total_points = 300
        self.user.tier = 'spark'
        self.user.save()

        response = self.client.get('/api/v1/me/thrive-circle/my_status/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('total_points', response.data)
        self.assertEqual(response.data['total_points'], 300)
        self.assertEqual(response.data['tier'], 'spark')

    def test_award_points_endpoint_valid(self):
        """Test POST /api/v1/me/thrive-circle/award-points/ with valid data"""
        response = self.client.post(
            '/api/v1/me/thrive-circle/award-points/',
            {'amount': 50, 'activity_type': 'comment', 'description': 'Posted helpful comment'},
        )

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(response.data['user']['total_points'], 50)
        self.assertFalse(response.data['tier_upgraded'])

    def test_award_points_endpoint_rejects_system_activities(self):
        """Test that system activity types are rejected via API"""
        response = self.client.post(
            '/api/v1/me/thrive-circle/award-points/',
            {
                'amount': 50,
                'activity_type': 'quiz_complete',  # System-only
                'description': 'Trying to cheat',
            },
        )

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_award_points_endpoint_validates_amount(self):
        """Test that excessive points amounts are rejected"""
        response = self.client.post(
            '/api/v1/me/thrive-circle/award-points/',
            {
                'amount': 10000,  # Exceeds max
                'activity_type': 'comment',
            },
        )

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_unauthenticated_access_denied(self):
        """Test that unauthenticated users cannot access endpoints"""
        self.client.force_authenticate(user=None)

        response = self.client.get('/api/v1/me/thrive-circle/my_status/')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)


class StreakTrackingTest(TestCase):
    """Tests for streak tracking functionality"""

    def setUp(self):
        self.user = User.objects.create_user(username='streakuser', email='streak@test.com', password='test123')  # noqa: S106

    def test_first_activity_sets_streak_to_one(self):
        """Test that first points activity sets streak to 1"""
        self.user.add_points(10, 'quiz_complete')
        self.user.refresh_from_db()

        self.assertEqual(self.user.current_streak_days, 1)
        self.assertEqual(self.user.longest_streak_days, 1)
        self.assertEqual(self.user.last_activity_date, timezone.now().date())

    def test_same_day_activity_doesnt_increment_streak(self):
        """Test that multiple activities on the same day don't increment streak"""
        self.user.add_points(10, 'quiz_complete')
        self.user.refresh_from_db()
        self.assertEqual(self.user.current_streak_days, 1)

        # Second activity same day
        self.user.add_points(20, 'project_create')
        self.user.refresh_from_db()
        self.assertEqual(self.user.current_streak_days, 1)  # Still 1, not 2

    @patch('django.utils.timezone.now')
    def test_consecutive_day_increments_streak(self, mock_now):
        """Test that activity on consecutive days increments streak"""
        # Day 1
        mock_now.return_value = datetime.datetime(2025, 1, 1, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.refresh_from_db()
        self.assertEqual(self.tier.current_streak_days, 1)

        # Day 2 (next day)
        mock_now.return_value = datetime.datetime(2025, 1, 2, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.refresh_from_db()
        self.assertEqual(self.tier.current_streak_days, 2)
        self.assertEqual(self.tier.longest_streak_days, 2)

        # Day 3
        mock_now.return_value = datetime.datetime(2025, 1, 3, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.refresh_from_db()
        self.assertEqual(self.tier.current_streak_days, 3)
        self.assertEqual(self.tier.longest_streak_days, 3)

    @patch('django.utils.timezone.now')
    def test_missing_day_resets_streak(self, mock_now):
        """Test that missing a day resets streak to 1"""
        # Build up a 3-day streak
        mock_now.return_value = datetime.datetime(2025, 1, 1, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        mock_now.return_value = datetime.datetime(2025, 1, 2, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        mock_now.return_value = datetime.datetime(2025, 1, 3, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.refresh_from_db()
        self.assertEqual(self.tier.current_streak_days, 3)

        # Skip to Day 5 (missed Day 4)
        mock_now.return_value = datetime.datetime(2025, 1, 5, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.refresh_from_db()

        self.assertEqual(self.tier.current_streak_days, 1)  # Reset to 1
        self.assertEqual(self.tier.longest_streak_days, 3)  # But longest is preserved

    @patch('django.utils.timezone.now')
    def test_longest_streak_preserved(self, mock_now):
        """Test that longest streak is preserved even after current resets"""
        # Build a 5-day streak
        for day in range(1, 6):
            mock_now.return_value = datetime.datetime(2025, 1, day, 12, 0, 0, tzinfo=datetime.UTC)
            self.tier.add_xp(10, 'quiz_complete')

        self.tier.refresh_from_db()
        self.assertEqual(self.tier.current_streak_days, 5)
        self.assertEqual(self.tier.longest_streak_days, 5)

        # Break streak
        mock_now.return_value = datetime.datetime(2025, 1, 10, 12, 0, 0, tzinfo=datetime.UTC)
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.refresh_from_db()

        self.assertEqual(self.tier.current_streak_days, 1)
        self.assertEqual(self.tier.longest_streak_days, 5)  # Still 5

    def test_concurrent_streak_updates(self):
        """Test that concurrent streak updates don't create race conditions (uses F() expressions)"""
        # This simulates concurrent requests updating the same user's streak
        self.tier.add_xp(10, 'quiz_complete')

        # Reload tier to simulate separate request
        tier_copy = UserTier.objects.get(pk=self.tier.pk)
        tier_copy.add_xp(20, 'project_create')

        # Both should see streak = 1 (same day)
        self.tier.refresh_from_db()
        self.assertEqual(self.tier.current_streak_days, 1)
        self.assertEqual(self.tier.total_xp, 30)


class WeeklyGoalTest(TestCase):
    """Tests for Phase 2 weekly goals functionality"""

    def setUp(self):
        self.user = User.objects.create_user(username='goaluser', email='goal@test.com', password='test123')  # noqa: S106
        self.tier = UserTier.objects.create(user=self.user)
        self.week_start = get_week_start()

        # Create a goal
        self.goal = WeeklyGoal.objects.create(
            user=self.user,
            goal_type='activities_3',
            week_start=self.week_start,
            week_end=self.week_start + timedelta(days=6),
            target_progress=3,
            xp_reward=30,
        )

    def test_goal_progress_increments(self):
        """Test that completing activities increments goal progress"""
        self.assertEqual(self.goal.current_progress, 0)

        # Complete a quiz (counts towards activities_3)
        self.tier.add_xp(10, 'quiz_complete')

        self.goal.refresh_from_db()
        self.assertEqual(self.goal.current_progress, 1)

    def test_goal_completion_awards_bonus_xp(self):
        """Test that completing a goal awards bonus XP"""
        # Complete 2 activities
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.add_xp(10, 'project_create')

        self.tier.refresh_from_db()
        self.assertEqual(self.tier.total_xp, 20)

        # Complete 3rd activity - should trigger goal completion
        self.tier.add_xp(10, 'side_quest')

        self.tier.refresh_from_db()
        self.goal.refresh_from_db()

        # Original XP (30) + Goal bonus (30) = 60
        self.assertEqual(self.tier.total_xp, 60)
        self.assertTrue(self.goal.is_completed)
        self.assertIsNotNone(self.goal.completed_at)

    def test_no_infinite_recursion_on_goal_completion(self):
        """Test that goal completion bonus XP doesn't trigger infinite recursion"""
        # This was a critical bug - bonus XP award would call check_weekly_goals again
        self.tier.add_xp(10, 'quiz_complete')
        self.tier.add_xp(10, 'project_create')

        # This should complete the goal and award bonus WITHOUT infinite recursion
        self.tier.add_xp(10, 'side_quest')

        # Verify we're still alive (no RecursionError)
        self.tier.refresh_from_db()
        self.assertTrue(self.tier.total_xp > 0)

        # Verify only ONE weekly_goal activity was created
        goal_activities = PointActivity.objects.filter(user=self.user, activity_type='weekly_goal')
        self.assertEqual(goal_activities.count(), 1)

    def test_concurrent_goal_updates(self):
        """Test that concurrent goal progress updates don't lose data (uses F() expressions)"""
        # Simulate two concurrent quiz completions
        self.tier.add_xp(10, 'quiz_complete')

        # Reload tier to simulate separate request
        tier_copy = UserTier.objects.get(pk=self.tier.pk)
        tier_copy.add_xp(10, 'quiz_complete')

        # Goal should have progress = 2 (both increments counted)
        self.goal.refresh_from_db()
        self.assertEqual(self.goal.current_progress, 2)

    def test_comment_activity_counts_towards_help_goal(self):
        """Test that comments count towards 'help_5' goal"""
        help_goal = WeeklyGoal.objects.create(
            user=self.user,
            goal_type='help_5',
            week_start=self.week_start,
            week_end=self.week_start + timedelta(days=6),
            target_progress=5,
            xp_reward=40,
        )

        self.tier.add_xp(5, 'comment', 'Helped someone')

        help_goal.refresh_from_db()
        self.assertEqual(help_goal.current_progress, 1)

    def test_completed_goal_not_incremented(self):
        """Test that already completed goals don't get incremented"""
        # Mark goal as completed
        self.goal.is_completed = True
        self.goal.current_progress = 3
        self.goal.save()

        # Try to add more activities
        self.tier.add_xp(10, 'quiz_complete')

        self.goal.refresh_from_db()
        self.assertEqual(self.goal.current_progress, 3)  # Still 3, not 4

    def test_weekly_goals_api_endpoint(self):
        """Test GET /api/v1/me/thrive-circle/weekly_goals/"""
        from rest_framework.test import APIClient

        client = APIClient()
        client.force_authenticate(user=self.user)

        response = client.get('/api/v1/me/thrive-circle/weekly_goals/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]['goal_type'], 'activities_3')


class CeleryTaskTest(TestCase):
    """Tests for Phase 2 Celery tasks"""

    def setUp(self):
        self.user1 = User.objects.create_user(username='user1', email='user1@test.com', password='test123')  # noqa: S106
        self.user2 = User.objects.create_user(username='user2', email='user2@test.com', password='test123')  # noqa: S106
        UserTier.objects.create(user=self.user1)
        UserTier.objects.create(user=self.user2)

    def test_create_weekly_goals_task(self):
        """Test that create_weekly_goals creates goals for all active users"""
        result = create_weekly_goals()

        self.assertEqual(result['users'], 2)
        self.assertEqual(result['goals_created'], 8)  # 2 users × 4 goal types

        # Verify goals were created
        week_start = get_week_start()
        user1_goals = WeeklyGoal.objects.filter(user=self.user1, week_start=week_start)
        self.assertEqual(user1_goals.count(), 4)

        user2_goals = WeeklyGoal.objects.filter(user=self.user2, week_start=week_start)
        self.assertEqual(user2_goals.count(), 4)

    def test_create_weekly_goals_idempotent(self):
        """Test that running create_weekly_goals twice doesn't duplicate goals"""
        create_weekly_goals()
        result = create_weekly_goals()  # Run again

        # Should not create duplicates
        self.assertEqual(result['goals_created'], 0)

        week_start = get_week_start()
        total_goals = WeeklyGoal.objects.filter(week_start=week_start).count()
        self.assertEqual(total_goals, 8)  # Still 8, not 16

    @patch('django.utils.timezone.now')
    def test_check_streak_bonuses_task(self, mock_now):
        """Test that check_streak_bonuses awards XP to users with streaks"""
        mock_now.return_value = datetime.datetime(2025, 1, 5, 12, 0, 0, tzinfo=datetime.UTC)

        # Give user1 a 3-day streak
        tier1 = UserTier.objects.get(user=self.user1)
        tier1.current_streak_days = 3
        tier1.last_activity_date = date(2025, 1, 5)
        tier1.save()

        # Give user2 a 5-day streak
        tier2 = UserTier.objects.get(user=self.user2)
        tier2.current_streak_days = 5
        tier2.last_activity_date = date(2025, 1, 5)
        tier2.save()

        result = check_streak_bonuses()

        self.assertEqual(result['active_users'], 2)
        self.assertEqual(result['bonuses_awarded'], 2)
        self.assertEqual(result['total_xp'], 40)  # (3*5) + (5*5) = 15 + 25 = 40

        # Verify XP was awarded
        tier1.refresh_from_db()
        tier2.refresh_from_db()
        self.assertEqual(tier1.total_xp, 15)
        self.assertEqual(tier2.total_xp, 25)

    def test_check_streak_bonuses_handles_errors(self):
        """Test that check_streak_bonuses continues on error"""
        # Create a user with a streak
        tier = UserTier.objects.get(user=self.user1)
        tier.current_streak_days = 3
        tier.last_activity_date = timezone.now().date()
        tier.save()

        # Mock add_xp to raise an error
        with patch.object(UserTier, 'add_xp', side_effect=Exception('Test error')):
            result = check_streak_bonuses()

        # Task should complete with 1 failure
        self.assertEqual(result['failed'], 1)
        self.assertIn(self.user1.id, result['failed_user_ids'])

    def test_create_weekly_goals_performance(self):
        """Test that bulk_create is used for performance"""
        # Create 50 users
        users = []
        for i in range(50):
            user = User.objects.create_user(username=f'bulkuser{i}', email=f'bulk{i}@test.com', password='test123')  # noqa: S106
            UserTier.objects.create(user=user)
            users.append(user)

        # Run task and measure query count
        from django.db import connection
        from django.test.utils import CaptureQueriesContext

        with CaptureQueriesContext(connection) as context:
            result = create_weekly_goals()

        # Should use bulk_create (only a few queries, not 200+)
        # Exact count may vary, but should be much less than 50 users × 4 goals = 200
        self.assertLess(len(context.captured_queries), 50)
        self.assertEqual(result['goals_created'], 208)  # 52 users × 4 goals


class CircleProjectsAPITest(APITestCase):
    """Tests for circle_projects API endpoint"""

    def setUp(self):
        """Create test users with different tiers and their projects"""
        # Create users in different tiers
        self.ember_user1 = User.objects.create_user(
            username='ember1', email='ember1@test.com', password=get_random_string(12)
        )
        self.ember_user2 = User.objects.create_user(
            username='ember2', email='ember2@test.com', password=get_random_string(12)
        )
        self.spark_user1 = User.objects.create_user(
            username='spark1', email='spark1@test.com', password=get_random_string(12)
        )
        self.spark_user2 = User.objects.create_user(
            username='spark2', email='spark2@test.com', password=get_random_string(12)
        )
        self.blaze_user = User.objects.create_user(
            username='blaze1', email='blaze1@test.com', password=get_random_string(12)
        )

        # Create tier statuses
        self.ember_tier1 = UserTier.objects.create(user=self.ember_user1, tier='ember', total_xp=0)
        self.ember_tier2 = UserTier.objects.create(user=self.ember_user2, tier='ember', total_xp=100)
        self.spark_tier1 = UserTier.objects.create(user=self.spark_user1, tier='spark', total_xp=600)
        self.spark_tier2 = UserTier.objects.create(user=self.spark_user2, tier='spark', total_xp=800)
        self.blaze_tier = UserTier.objects.create(user=self.blaze_user, tier='blaze', total_xp=1600)

        # Import Project model
        from core.projects.models import Project

        # Create published projects for each user
        self.ember1_project = Project.objects.create(
            user=self.ember_user1,
            title='Ember Project 1',
            slug='ember-project-1',
            description='A project by ember user 1',
            type='other',
            is_published=True,
            is_archived=False,
            published_at=timezone.now(),
        )

        self.ember2_project = Project.objects.create(
            user=self.ember_user2,
            title='Ember Project 2',
            slug='ember-project-2',
            description='A project by ember user 2',
            type='other',
            is_published=True,
            is_archived=False,
            published_at=timezone.now(),
        )

        self.spark1_project = Project.objects.create(
            user=self.spark_user1,
            title='Spark Project 1',
            slug='spark-project-1',
            description='A project by spark user 1',
            type='other',
            is_published=True,
            is_archived=False,
            published_at=timezone.now(),
        )

        self.spark2_project = Project.objects.create(
            user=self.spark_user2,
            title='Spark Project 2',
            slug='spark-project-2',
            description='A project by spark user 2',
            type='other',
            is_published=True,
            is_archived=False,
            published_at=timezone.now(),
        )

        self.blaze_project = Project.objects.create(
            user=self.blaze_user,
            title='Blaze Project 1',
            slug='blaze-project-1',
            description='A project by blaze user',
            type='other',
            is_published=True,
            is_archived=False,
            published_at=timezone.now(),
        )

        # Create an unpublished project (should not appear in results)
        self.unpublished_project = Project.objects.create(
            user=self.ember_user1,
            title='Unpublished Project',
            slug='unpublished-project',
            description='Not published',
            type='other',
            is_published=False,
            is_archived=False,
        )

        # Create an archived project (should not appear in results)
        self.archived_project = Project.objects.create(
            user=self.ember_user2,
            title='Archived Project',
            slug='archived-project',
            description='Archived',
            type='other',
            is_published=True,
            is_archived=True,
            published_at=timezone.now(),
        )

    def test_ember_user_sees_only_ember_projects(self):
        """Ember users should only see projects from other Ember users"""
        self.client.force_authenticate(user=self.ember_user1)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        projects = response.json()

        # Should only see ember2's project (not own project, not other tiers)
        self.assertEqual(len(projects), 1)
        self.assertEqual(projects[0]['slug'], 'ember-project-2')

    def test_spark_user_sees_only_spark_projects(self):
        """Spark users should only see projects from other Spark users"""
        self.client.force_authenticate(user=self.spark_user1)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        projects = response.json()

        # Should only see spark2's project (not own project, not other tiers)
        self.assertEqual(len(projects), 1)
        self.assertEqual(projects[0]['slug'], 'spark-project-2')

    def test_user_does_not_see_own_projects(self):
        """Users should not see their own projects in circle feed"""
        self.client.force_authenticate(user=self.ember_user1)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        projects = response.json()

        # Should not include own project
        project_slugs = [p['slug'] for p in projects]
        self.assertNotIn('ember-project-1', project_slugs)

    def test_unpublished_projects_not_shown(self):
        """Unpublished projects should not appear in circle feed"""
        self.client.force_authenticate(user=self.ember_user2)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        projects = response.json()

        # Should not include unpublished project
        project_slugs = [p['slug'] for p in projects]
        self.assertNotIn('unpublished-project', project_slugs)

    def test_archived_projects_not_shown(self):
        """Archived projects should not appear in circle feed"""
        self.client.force_authenticate(user=self.ember_user1)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        projects = response.json()

        # Should not include archived project
        project_slugs = [p['slug'] for p in projects]
        self.assertNotIn('archived-project', project_slugs)

    def test_tier_change_updates_visible_projects(self):
        """When a user's tier changes, they should see different projects"""
        # Start as ember user
        self.client.force_authenticate(user=self.ember_user1)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')
        ember_projects = response.json()
        self.assertEqual(len(ember_projects), 1)
        self.assertEqual(ember_projects[0]['slug'], 'ember-project-2')

        # Upgrade to spark tier
        self.ember_tier1.tier = 'spark'
        self.ember_tier1.total_xp = 600
        self.ember_tier1.save()

        # Should now see spark projects
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')
        spark_projects = response.json()
        self.assertEqual(len(spark_projects), 2)
        spark_slugs = {p['slug'] for p in spark_projects}
        self.assertEqual(spark_slugs, {'spark-project-1', 'spark-project-2'})

    def test_limit_parameter_works(self):
        """Limit parameter should restrict number of results"""
        # Create more ember projects
        from core.projects.models import Project

        for i in range(10, 20):  # Start from 10 to avoid email conflicts
            user = User.objects.create_user(
                username=f'ember_user_{i}', email=f'ember_test_{i}@test.com', password=get_random_string(12)
            )
            UserTier.objects.create(user=user, tier='ember', total_xp=50)
            Project.objects.create(
                user=user,
                title=f'Ember Project {i}',
                slug=f'ember-project-extra-{i}',
                description='Extra project',
                type='other',
                is_published=True,
                is_archived=False,
                published_at=timezone.now(),
            )

        self.client.force_authenticate(user=self.ember_user1)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/?limit=5')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        projects = response.json()
        self.assertEqual(len(projects), 5)

    def test_max_limit_enforced(self):
        """Limit should not exceed 50"""
        self.client.force_authenticate(user=self.ember_user1)
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/?limit=100')

        # Should work but limit to 50 (even if we don't have 50 projects)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_unauthenticated_user_denied(self):
        """Unauthenticated users should not access circle projects"""
        response = self.client.get('/api/v1/me/thrive-circle/circle-projects/')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)


class SideQuestModelTest(TestCase):
    """Tests for SideQuest model"""

    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'  # noqa: S106
        )

    def test_create_side_quest(self):
        """Test creating a side quest"""
        quest = SideQuest.objects.create(
            title='Quiz Master',
            description='Complete 10 quizzes',
            quest_type='quiz_mastery',
            difficulty='medium',
            requirements={'target': 10},
            xp_reward=100,
        )
        self.assertEqual(quest.title, 'Quiz Master')
        self.assertEqual(quest.xp_reward, 100)
        self.assertTrue(quest.is_active)

    def test_is_available_no_dates(self):
        """Quest with no start/end dates should be available if active"""
        quest = SideQuest.objects.create(
            title='Test Quest',
            description='Test',
            quest_type='quiz_mastery',
            difficulty='easy',
            requirements={},
            xp_reward=50,
            is_active=True,
        )
        self.assertTrue(quest.is_available())

    def test_is_available_inactive(self):
        """Inactive quest should not be available"""
        quest = SideQuest.objects.create(
            title='Test Quest',
            description='Test',
            quest_type='quiz_mastery',
            difficulty='easy',
            requirements={},
            xp_reward=50,
            is_active=False,
        )
        self.assertFalse(quest.is_available())

    def test_is_available_not_started(self):
        """Quest that hasn't started should not be available"""
        future_date = timezone.now() + timedelta(days=7)
        quest = SideQuest.objects.create(
            title='Future Quest',
            description='Test',
            quest_type='quiz_mastery',
            difficulty='easy',
            requirements={},
            xp_reward=50,
            starts_at=future_date,
        )
        self.assertFalse(quest.is_available())

    def test_is_available_expired(self):
        """Expired quest should not be available"""
        past_date = timezone.now() - timedelta(days=7)
        quest = SideQuest.objects.create(
            title='Expired Quest',
            description='Test',
            quest_type='quiz_mastery',
            difficulty='easy',
            requirements={},
            xp_reward=50,
            expires_at=past_date,
        )
        self.assertFalse(quest.is_available())


class UserSideQuestModelTest(TestCase):
    """Tests for UserSideQuest model"""

    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'  # noqa: S106
        )
        self.quest = SideQuest.objects.create(
            title='Project Master',
            description='Create 5 projects',
            quest_type='project_showcase',
            difficulty='medium',
            requirements={'target': 5},
            xp_reward=150,
        )

    def test_create_user_side_quest(self):
        """Test creating a user side quest"""
        user_quest = UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest,
            status='in_progress',
            current_progress=0,
            target_progress=5,
        )
        self.assertEqual(user_quest.status, 'in_progress')
        self.assertEqual(user_quest.current_progress, 0)
        self.assertEqual(user_quest.target_progress, 5)
        self.assertFalse(user_quest.is_completed)

    def test_progress_percentage(self):
        """Test progress percentage calculation"""
        user_quest = UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest,
            current_progress=3,
            target_progress=5,
        )
        self.assertEqual(user_quest.progress_percentage, 60)

    def test_complete_quest_awards_xp(self):
        """Test that completing a quest awards XP"""
        user_quest = UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest,
            current_progress=5,
            target_progress=5,
        )

        # Create tier before completing quest
        tier = UserTier.objects.create(user=self.user, tier='ember', total_xp=0)

        user_quest.complete()

        self.assertTrue(user_quest.is_completed)
        self.assertEqual(user_quest.status, 'completed')
        self.assertEqual(user_quest.xp_awarded, 150)
        self.assertIsNotNone(user_quest.completed_at)

        # Check that XP was added to tier
        tier.refresh_from_db()
        self.assertEqual(tier.total_xp, 150)


class SideQuestAPITest(APITestCase):
    """Tests for SideQuest API endpoints"""

    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'  # noqa: S106
        )

        # Create some quests
        self.quest1 = SideQuest.objects.create(
            title='Quiz Master',
            description='Complete 10 quizzes',
            quest_type='quiz_mastery',
            difficulty='easy',
            requirements={'target': 10},
            xp_reward=100,
        )

        self.quest2 = SideQuest.objects.create(
            title='Project Showcase',
            description='Create 5 projects',
            quest_type='project_showcase',
            difficulty='medium',
            requirements={'target': 5},
            xp_reward=200,
        )

        # Create an inactive quest
        self.inactive_quest = SideQuest.objects.create(
            title='Inactive Quest',
            description='Should not appear',
            quest_type='quiz_mastery',
            difficulty='hard',
            requirements={},
            xp_reward=500,
            is_active=False,
        )

    def test_list_available_quests(self):
        """Test listing available side quests"""
        self.client.force_authenticate(user=self.user)
        response = self.client.get('/api/v1/me/side-quests/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        quests = response.json()
        self.assertEqual(len(quests), 2)

        # Should not include inactive quest
        titles = {q['title'] for q in quests}
        self.assertNotIn('Inactive Quest', titles)

    def test_get_specific_quest(self):
        """Test getting a specific side quest"""
        self.client.force_authenticate(user=self.user)
        response = self.client.get(f'/api/v1/me/side-quests/{self.quest1.id}/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()
        self.assertEqual(data['title'], 'Quiz Master')
        self.assertEqual(data['xp_reward'], 100)

    def test_start_quest(self):
        """Test starting a side quest"""
        self.client.force_authenticate(user=self.user)
        response = self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/start/')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        data = response.json()
        self.assertEqual(data['status'], 'in_progress')
        self.assertEqual(data['current_progress'], 0)
        self.assertEqual(data['target_progress'], 10)

        # Verify UserSideQuest was created
        self.assertTrue(
            UserSideQuest.objects.filter(user=self.user, side_quest=self.quest1).exists()
        )

    def test_start_quest_twice_returns_existing(self):
        """Test starting a quest that's already started returns existing"""
        self.client.force_authenticate(user=self.user)

        # Start once
        response1 = self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/start/')
        self.assertEqual(response1.status_code, status.HTTP_201_CREATED)

        # Try starting again
        response2 = self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/start/')
        self.assertEqual(response2.status_code, status.HTTP_200_OK)

        # Should only have one UserSideQuest record
        self.assertEqual(
            UserSideQuest.objects.filter(user=self.user, side_quest=self.quest1).count(),
            1
        )

    def test_start_completed_quest_fails(self):
        """Test starting a completed quest fails"""
        self.client.force_authenticate(user=self.user)

        # Create and complete the quest
        user_quest = UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest1,
            status='completed',
            current_progress=10,
            target_progress=10,
            is_completed=True,
        )

        response = self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/start/')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('already completed', response.json()['error'])

    def test_update_progress(self):
        """Test updating quest progress"""
        self.client.force_authenticate(user=self.user)

        # Start quest
        self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/start/')

        # Update progress
        response = self.client.post(
            f'/api/v1/me/side-quests/{self.quest1.id}/update-progress/',
            {'increment': 3}
        )

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()
        self.assertEqual(data['current_progress'], 3)
        self.assertEqual(data['status'], 'in_progress')

    def test_update_progress_auto_completes(self):
        """Test that progress update auto-completes when target reached"""
        self.client.force_authenticate(user=self.user)

        # Create tier for XP award
        UserTier.objects.create(user=self.user, tier='ember', total_xp=0)

        # Start quest
        self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/start/')

        # Update progress to completion
        response = self.client.post(
            f'/api/v1/me/side-quests/{self.quest1.id}/update-progress/',
            {'increment': 10}
        )

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()
        self.assertEqual(data['status'], 'completed')
        self.assertTrue(data['is_completed'])
        self.assertEqual(data['xp_awarded'], 100)

    def test_manual_complete_quest(self):
        """Test manually completing a quest"""
        self.client.force_authenticate(user=self.user)

        # Create tier for XP award
        UserTier.objects.create(user=self.user, tier='ember', total_xp=0)

        # Start quest
        self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/start/')

        # Complete manually
        response = self.client.post(f'/api/v1/me/side-quests/{self.quest1.id}/complete/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        data = response.json()
        self.assertTrue(data['is_completed'])
        self.assertEqual(data['xp_awarded'], 100)

    def test_get_my_quests(self):
        """Test getting user's active/completed quests"""
        self.client.force_authenticate(user=self.user)

        # Start some quests
        UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest1,
            status='in_progress',
            current_progress=5,
            target_progress=10,
        )

        UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest2,
            status='completed',
            current_progress=5,
            target_progress=5,
            is_completed=True,
        )

        response = self.client.get('/api/v1/me/side-quests/my-quests/')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        quests = response.json()
        self.assertEqual(len(quests), 2)

    def test_filter_my_quests_by_status(self):
        """Test filtering my quests by status"""
        self.client.force_authenticate(user=self.user)

        # Create quests with different statuses
        UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest1,
            status='in_progress',
            current_progress=5,
            target_progress=10,
        )

        UserSideQuest.objects.create(
            user=self.user,
            side_quest=self.quest2,
            status='completed',
            current_progress=5,
            target_progress=5,
            is_completed=True,
        )

        # Filter by in_progress
        response = self.client.get('/api/v1/me/side-quests/my-quests/?status=in_progress')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        quests = response.json()
        self.assertEqual(len(quests), 1)
        self.assertEqual(quests[0]['status'], 'in_progress')

    def test_unauthenticated_access_denied(self):
        """Test that unauthenticated users cannot access side quests"""
        response = self.client.get('/api/v1/me/side-quests/')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
